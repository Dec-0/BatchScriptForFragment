#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
Getopt::Long::Configure qw(no_ignore_case);
use File::Basename;
use FindBin qw($Bin);
use lib "$Bin/.Modules";
use Parameter::BinList;

my ($HelpFlag,$BinList,$BeginTime);
my $ThisScriptName = basename $0;
my ($File4Ori,$File4Merge,$Len4Merge,$Len4OverLap);
my $HelpInfo = <<USAGE;

 $ThisScriptName
 Auther: zhangdong_xie\@foxmail.com

  This script was used to merge the result generated by InsertSizeInfoCollect.
  本脚本用于按行合并脚本“InsertSizeInfoCollect”生成的文件，也就是以第一列分组，组内按指定的数量以及叠加的长度来合并数据。

 -i      ( Required ) File generated by InsertSizeInfoCollect;
 -o      ( Required ) File for the merged result;

 -m      ( Optional ) The number of lines to be merge into one (default: 1);
 -n      ( Optional ) The lenght for overlap. If the same with \'-m\', that means no overlap (default: 1);
 -bin    ( Optional ) List for searching of related bin or scripts; 
 -h      ( Optional ) Help infomation;

USAGE

GetOptions(
	'i=s' => \$File4Ori,
	'o=s' => \$File4Merge,
	'm:i' => \$Len4Merge,
	'n:i' => \$Len4OverLap,
	'bin:s' => \$BinList,
	'h!' => \$HelpFlag
) or die $HelpInfo;

if($HelpFlag || !$File4Ori || !$File4Merge)
{
	die $HelpInfo;
}
else
{
	$BeginTime = ScriptBegin(0,$ThisScriptName);
	
	$Len4Merge = 1 unless($Len4Merge);
	$Len4OverLap = 1 unless($Len4OverLap);
	die "[ Error ] Len4OverLap > Len4Merge\n" if($Len4OverLap > $Len4Merge);
	#$BinList = BinListGet() if(!$BinList);
	#$Ref = BinSearch("Reference",$BinList);
}

if(1)
{
	# 计算合并的范围列表；
	my (@From,@To) = ();
	if(1)
	{
		my $tInfo4Line = "";
		$tInfo4Line = `cat $File4Ori | grep -v ^# | cut -f 1 | uniq -c | sed -E 's/^\\s+//g' | awk -F ' ' '{print \$2"\\t"\$1}'` unless($File4Ori =~ /\.gz$/);
		$tInfo4Line = `zcat $File4Ori | grep -v ^# | cut -f 1 | uniq -c | sed -E 's/^\\s+//g' | awk -F ' ' '{print \$2"\\t"\$1}'` if($File4Ori =~ /\.gz$/);
		my @Items = split /\n/, $tInfo4Line;
		my $AccumNum = 0;
		for my $i (0 .. $#Items)
		{
			my ($Chr,$Num) = split /\t/, $Items[$i];
			my $tFrom = $AccumNum + 1;
			$AccumNum += $Num;
			# 假如数量都不够合并，直接忽略；
			next unless($Num > $Len4Merge);
			
			my $tTo = $tFrom + $Len4Merge - 1;
			my $MaxLoop = 10000000;
			while($tTo <= $AccumNum)
			{
				push @From, $tFrom;
				push @To, $tTo;
				$tFrom += $Len4OverLap;
				$tTo = $tFrom + $Len4Merge - 1;
				
				$MaxLoop --;
				last unless($MaxLoop > 0);
			}
		}
	}
	
	# 确定数据起始列号；
	my $InitialId = 0;
	if(1)
	{
		my $Header = "";
		$Header = `cat $File4Ori | grep ^# | tail -n1` unless($File4Ori =~ /\.gz$/);
		$Header = `zcat $File4Ori | grep ^# | tail -n1` if($File4Ori =~ /\.gz$/);
		chomp $Header;
		my @Items = split /\t/, $Header;
		$Items[0] =~ s/^#//;
		for my $i (0 .. $#Items)
		{
			unless($Items[$i] =~ /\D/)
			{
				$InitialId = $i;
				last;
			}
		}
		die "[ Error ] No Comment Line or can't locate the columns for line info or id.\n" unless($InitialId > 0);
	}
	
	# 读入所有数据；
	open(ORI,"cat $File4Ori |") or die $! unless($File4Ori =~ /\.gz$/);
	open(ORI,"zcat $File4Ori |") or die $! if($File4Ori =~ /\.gz$/);
	open(MERGE,"> $File4Merge") or die $! unless($File4Merge =~ /\.gz$/);
	open(MERGE,"| gzip > $File4Merge") or die $! if($File4Merge =~ /\.gz$/);
	my @Content = ();
	while(my $Line = <ORI>)
	{
		if($Line =~ /^#/)
		{
			my @Cols = split /\t/, $Line;
			print MERGE join("\t","#Chr","From","To",@Cols[$InitialId .. $#Cols]);
			next;
		}
		chomp $Line;
		push @Content, $Line;
	}
	close ORI;
	
	for my $i (0 .. $#From)
	{
		$From[$i] --;
		$To[$i] --;
		
		my ($Chr,$AreaFrom,$AreaTo) = ("-","-","-");
		my @Value = ();
		for my $j ($From[$i] .. $To[$i])
		{
			my @Cols = split /\t/, $Content[$j];
			if($j == $From[$i])
			{
				$Chr = $Cols[0];
				$AreaFrom = $Cols[1] if($InitialId > 1);
			}
			elsif($j == $To[$i])
			{
				if($InitialId > 2)
				{
					$AreaTo = $Cols[2];
				}
				elsif($InitialId > 1)
				{
					$AreaTo = $Cols[1];
				}
			}
			
			
			if($j == $From[$i])
			{
				@Value = @Cols[$InitialId .. $#Cols];
			}
			else
			{
				for my $k (0 .. $#Value)
				{
					$Value[$k] += $Cols[$InitialId + $k];
				}
			}
		}
		print MERGE join("\t",$Chr,$AreaFrom,$AreaTo,@Value),"\n";
	}
	close MERGE;
}
printf "[ %s ] The end.\n",TimeString(time,$BeginTime);


######### Sub functions ##########
